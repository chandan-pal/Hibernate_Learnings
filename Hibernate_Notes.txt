HIBERNATE
	- ORM Tool (Object Relational Mapping)
	- used in data layer of applications
	- implements JPA
	
What is an ORM (Object Relational Mapping) Tool:
	- It solves the common problem of saving object from java to a persistent database against a table which generally represents the class schema.
	- It solves the common problem of:
		1. mapping member variables to columns
		2. mapping relationships
		3. handling data types
		4. mamaging changes to object state
		
Steps we generally have to perform without hibernate:
	- JDBC Database configuration
	- The Model(bean) object
	- Service method to create the model object
	- Database design
	- DAO methods to save the object using SQL queries
	
Steps with hibernate:
	- JDBC database configuration (hibernate configuration)
	- The Model (bean) object - Annotations
	- Service method to create the model object - use the hibernate API
	- Database design - Not Needed!
	- DAO methods to save the object using SQL queries - Not Needed!
	
What is a dialect?
	dialect is a configuration for hibernate to know what kind of language to use while talking to database.
	Even though we use SQL to talk to a dabase, but there are some nuiances which are specific to a database.
	The way we use queries in Oracle is different is from the way we run queries in MySQL.
	if we specify the dialect, hibernate will then use that particular dialect to write sql queries.
	
Natural Key vs Surrogate Key:
	such columns which are unique as per business logic as called natural key.
	but if there is not any column or you are not sure about any column which can be marked as unique, then a separtae column (like serialNo.) just for uniqueness of rows. such keys/colums is called as surrogate key.
	
	
hibernate configurations:
      <!-- SQL Dialect -->
      <property name="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</property>
      
      <!-- Database connection settings -->
      <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/DBPocHibernate</property>
      <property name="hibernate.connection.username">dbasys</property>
      <property name="hibernate.connection.password">oracle</property>
      
      <!-- (create/update) : drop existing and re-create database schema / update in existing schema -->
      <property name="hbm2ddl.auto">create</property>
      
	  <!-- show sql queries getting executed in console -->
      <property name="show_sql">true</property>
      
	  <!-- classes in whic to look for hibernate annotations -->
      <mapping class="in.chandanpal.pochibernate.model.UserDetails"/>
	
	

Annotations:
@Entity (javax.persistence) : tells hibernate to treat the class as an entity
@Entity(name="USER_DETAILS"): tells hibernate to create entity with name passed instead of the class name
@Id (javax.persistence) : tells hibernate to treat the field as primary key
@Column : tells hibernate to create column corresponding to the field (it is optional, even if not provided, column will be created)
@Column(name="USER_NAME") : tells hibernate to create column with the name passed instead of the field name directly.
@Table(name="USER_DETAILS") : tells hibernate to create a table with the name passed.
@Transient : tell hibernate not to consider a field for persistence (hibernate also ignores fields which are transient or static variable)
@Temporal(TemporalType.DATE) : for date fields to use different formats of date
@Lob : large object (clob/blob) hibernate chooses a clob or blob depending on the type (byte array or String)
@GeneratedValue : tells hibernate to generate an automatic value for that field/column with default generation strategy
@GeneratedValue(strategy=GenerationType.SEQUENCE) : tells hibernate to generate an automatic value for that field/column with specific strategy

Note: @Id, @Column can also added on top of getter method in place of on top of the field (In that case the values which are returned from the getter will be saved, and not the value of the field directly)

Using Hibernate API
	1. create a session factory
		(only one object per application)
		creates sessions depending of no of sessions required
		we get a session from the session factory to do any operation in database
	